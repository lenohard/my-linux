(require sicp)
(print-as-expression #f)
;Utils
(define (square n) ( * n  n ))
(define (cube x) (* x x x))
(define (insert-between v xs)
  (cond ((null? xs) xs)
        ((null? (cdr xs)) xs)
        (else (cons (car xs)
                    (cons v (insert-between v (cdr xs)))))))
(define (display-all sep . vs)
  (for-each display (insert-between sep vs)))
(define (average a b) (/ (+ a b ) 2))
(define (isNum? A)
  (cond ((null? A) #f)
        ((pair? A) #f)
        (else #t)))
(define A '(1 2 3 4 5))
(define T (list(list 2 3) (list 3 4 (list 3 7 8) 5) 8  10))
(define matrix (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12))) 
(define matrix2 (list (list 1 2 3 4 9) (list 5 6 7 8 20) (list 9 10 11 12 18) (list 13 14 15 16 17))) 
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define (last l)
  (if (null? l) nil
    (car (reverse l))))
(define (enumerate-tree tree)
  (cond (( null? tree ) nil)
        ((not (pairs? tree) (list tree)))
        (else (append (enumerate-tree (car tree)) (enumerate-tree (cdr tree))))))
(define (reverse A)
  (define (reverse-iter  A B)
    (if (null?  A) B
      (reverse-iter  (cdr A) (cons (car A) B))))
  (reverse-iter  A '()))
(define (accumulate op initial sequence)
  (if (null? sequence)
    initial
    (op (car sequence)
        (accumulate op initial (cdr sequence)))))
(define (enumerate-interval low high)
  (if (> low high)
    nil
    (cons low (enumerate-interval (+ low 1) high))))
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
